<script>
    // ----------------------------------------------------
    //  ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã¨å®šæ•°
    // ----------------------------------------------------
    const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']; 
    const VALUE_MAP = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14};
    const HAND_RANKINGS = [
        'ãƒã‚¤ã‚«ãƒ¼ãƒ‰', 'ãƒ¯ãƒ³ãƒšã‚¢', 'ãƒ„ãƒ¼ãƒšã‚¢', 'ã‚¹ãƒªãƒ¼ã‚«ãƒ¼ãƒ‰', 'ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆ', 
        'ãƒ•ãƒ©ãƒƒã‚·ãƒ¥', 'ãƒ•ãƒ«ãƒã‚¦ã‚¹', 'ãƒ•ã‚©ãƒ¼ã‚«ãƒ¼ãƒ‰', 'ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥', 'ãƒ­ã‚¤ãƒ¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥'
    ];
    const INITIAL_CHIPS = 1000;

    // HTMLè¦ç´ 
    const els = {};
    ['chipsAmount', 'potAmount', 'dealerCards', 'playerCards', 'communityCards', 
     'messagePopup', 'dealButton', 'actionButtons', 'foldButton', 'checkCallButton', 
     'raiseButton', 'anteAmount', 'raiseAmount', 'dealerCurrentBet', 'playerCurrentBet', 
     'dealerHandStatus', 'playerHandStatus', 'postGameButtons', 'ruleModal', 
     'closeModal', 'ruleButton', 'tutorialButton', 'nextGameButton']
    .forEach(id => els[id] = document.getElementById(id));

    // ã‚²ãƒ¼ãƒ å¤‰æ•°
    let chips = INITIAL_CHIPS; 
    let pot = 0;
    let deck = [];
    let dealerHand = []; 
    let playerHand = []; 
    let communityCards = []; 
    let dealerBet = 0;
    let playerBet = 0;
    let currentBettingRound = 0; 
    let isGameOver = true;
    let isTutorial = false; 
    let tutorialStep = 0; 

    // ----------------------------------------------------
    //  ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
    // ----------------------------------------------------

    function makeCard(suit, value) { return { suit, value }; }
    function drawCard() { return deck.pop(); }

    function updateDisplay() {
        els.chipsAmount.textContent = chips;
        els.potAmount.textContent = pot + dealerBet + playerBet;
        els.dealerCurrentBet.textContent = dealerBet;
        els.playerCurrentBet.textContent = playerBet;
        
        // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä¸­ã¯UIã‚’ãƒ­ãƒƒã‚¯
        els.anteAmount.disabled = isTutorial;
        els.raiseAmount.disabled = isTutorial;

        // ãƒ™ãƒƒãƒˆé¡ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        els.anteAmount.max = chips;
        els.raiseAmount.max = chips;
    }

    function getCardHtml(card, isHidden = false) {
        if (isHidden) return `<div class="card hidden">POKER<br>CARD</div>`;
        const color = (card.suit === 'â™¥' || card.suit === 'â™¦') ? 'red' : 'black';
        return `
            <div class="card" style="color: ${color};">
                <div class="card-value">${card.value}</div>
                <div class="card-suit">${card.suit}</div>
                <div class="card-value">${card.value}</div>
            </div>
        `;
    }

    function renderHands(showDealer = false) {
        els.dealerCards.innerHTML = dealerHand.map(card => 
            getCardHtml(card, !showDealer)
        ).join('');
        els.playerCards.innerHTML = playerHand.map(card => getCardHtml(card)).join('');
        els.communityCards.innerHTML = communityCards.map(card => getCardHtml(card)).join('');

        if (showDealer && communityCards.length === 5) {
             const playerResult = evaluateHand([...playerHand, ...communityCards]);
             const dealerResult = evaluateHand([...dealerHand, ...communityCards]);
             els.playerHandStatus.textContent = playerResult.name;
             els.dealerHandStatus.textContent = dealerResult.name;
        } else {
             if (communityCards.length >= 3) {
                const currentHand = evaluateHand([...playerHand, ...communityCards]);
                els.playerHandStatus.textContent = `(${currentHand.name}ã®å¯èƒ½æ€§)`;
             } else {
                 els.playerHandStatus.textContent = 'ï¼Ÿ';
             }
             els.dealerHandStatus.textContent = '?';
        }
    }

    function createAndShuffleDeck() {
        deck = [];
        for (let suit of SUITS) {
            for (let value of VALUES) {
                deck.push(makeCard(suit, value));
            }
        }
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }

    function displayDealerMessage(type, amount = 0, handName = '', customMessage = '') {
        const currentPot = pot + dealerBet + playerBet;
        const potMsg = `ãƒãƒƒãƒˆ: ${currentPot}`;
        let aa = isTutorial ? '(ğŸ¤–)' : '(^_^;)';
        let message = customMessage || '';

        if (!customMessage) {
            switch (type) {
                case 'start': aa = '(*^.^*)'; message = `ã‚¢ãƒ³ãƒ†ã‚£ã‚’æ±ºã‚ã¦ã€ã‚²ãƒ¼ãƒ é–‹å§‹ã‚ˆï¼`; break;
                case 'ante': aa = '(^_^)'; message = `ã‚¢ãƒ³ãƒ†ã‚£ ${amount}ã€‚ã•ã‚ã€å‹è² ã‚ˆï¼`; break;
                case 'flop': aa = '(Â°Ï‰Â°)'; message = `ãƒ•ãƒ­ãƒƒãƒ—ï¼3æšã®ã‚«ãƒ¼ãƒ‰ãŒå…¬é–‹ã•ã‚ŒãŸã‚ã€‚${potMsg}`; break;
                case 'turn': aa = '(-Ï‰-)'; message = `ã‚¿ãƒ¼ãƒ³ï¼4æšç›®ã®ã‚«ãƒ¼ãƒ‰ã‚ˆã€‚${potMsg}`; break;
                case 'river': aa = '(ãƒ¡_ãƒ¡)'; message = `ãƒªãƒãƒ¼ï¼æœ€çµ‚ã‚«ãƒ¼ãƒ‰ã‚ˆã€‚${potMsg}`; break;
                case 'dealer_bet': aa = '(^-^)/'; message = `ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãŒ ${amount} ãƒ™ãƒƒãƒˆã€‚ã‚ãªãŸã®ç•ªã‚ˆã€‚`; break;
                case 'dealer_call': aa = '(-_-)'; message = `ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã¯ã‚³ãƒ¼ãƒ«ã€‚æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«ç§»ã‚‹ã‚ã€‚`; break;
                case 'dealer_raise': aa = 'o(^-^)o'; message = `ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãŒ ${amount} ã«ãƒ¬ã‚¤ã‚ºã€‚ã©ã†ã™ã‚‹ï¼Ÿ`; break;
                case 'dealer_check': aa = '(^_^)'; message = `ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã¯ãƒã‚§ãƒƒã‚¯ã‚ˆã€‚ã‚ãªãŸã®ç•ªã‚ˆã€‚`; break;
                case 'player_win_showdown': aa = '(^O^)/'; message = `ğŸ‰ **${handName}** ã§å‹åˆ©ï¼ãƒãƒƒãƒˆ ${currentPot} ã‚’ç²å¾—ï¼`; break;
                case 'dealer_win_showdown': aa = '(-_ãƒ¡)'; message = `ğŸ’” ${handName} ã«è² ã‘ãŸã‚ã€‚ãƒãƒƒãƒ—ã‚’å¤±ã£ãŸã‚ã­ã€‚`; break;
                case 'push': aa = '(-_-)'; message = `ãƒ—ãƒƒã‚·ãƒ¥ï¼ˆå¼•ãåˆ†ã‘ï¼‰ã€‚ãƒãƒƒãƒˆ ${currentPot} ã‚’åˆ†ã‘åˆã†ã‚ã€‚`; break;
                case 'player_fold': aa = 'ãƒ»_ãƒ»'; message = `ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã­ã€‚ãƒãƒƒãƒˆ ${currentPot} ã¯ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã®ã‚‚ã®ã‚ˆã€‚`; break;
                case 'dealer_fold': aa = 'ï¼¼(>_<)ï¼'; message = `ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãŒé™ã‚ŠãŸã‚ï¼ãƒãƒƒãƒˆ ${currentPot} ã‚’ç²å¾—ï¼`; break;
                default: aa = '^_^;'; message = 'æ¬¡ã®å‹è² ã¸ã©ã†ãã€‚';
            }
        }
        
        els.messagePopup.innerHTML = `<div class="dealer-aa">${aa}</div>${message}<br><small>(ã‚¯ãƒªãƒƒã‚¯ã§æ¬¡ã¸)</small>`;
        els.messagePopup.style.display = 'block';
    }

    window.hideMessagePopup = function() {
        els.messagePopup.style.display = 'none';
        if (isTutorial) handleTutorialStep();
    }
    
    // ãƒãƒ¼ã‚«ãƒ¼å½¹ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (ç°¡ç•¥åŒ–)
    function evaluateHand(cards) {
        if (cards.length < 5) return { rank: 0, name: 'ãƒã‚¤ã‚«ãƒ¼ãƒ‰', highCardValue: 0 };
        
        const valuesCount = cards.reduce((acc, card) => {
            const value = card.value;
            acc[value] = (acc[value] || 0) + 1;
            return acc;
        }, {});
        
        const suitsCount = cards.reduce((acc, card) => {
            acc[card.suit] = (acc[card.suit] || 0) + 1;
            return acc;
        }, {});

        let rank = 0; 
        let pairs = 0;
        let triples = 0;
        let quads = 0;

        for (const count of Object.values(valuesCount)) {
            if (count === 2) pairs++;
            if (count === 3) triples++;
            if (count === 4) quads++;
        }

        if (quads > 0) rank = 7; 
        else if (triples > 0 && pairs >= 1) rank = 6; 
        else if (triples > 0) rank = 3; 
        else if (pairs >= 2) rank = 2; 
        else if (pairs === 1) rank = 1; 

        let uniqueValues = [...new Set(cards.map(card => VALUE_MAP[card.value]))].sort((a, b) => a - b);
        if (uniqueValues.includes(14)) uniqueValues.unshift(1); // Ace-low for A-5 straight

        let isStraight = false;
        let highStraightValue = 0;
        if (uniqueValues.length >= 5) {
            for (let i = 0; i <= uniqueValues.length - 5; i++) {
                if (uniqueValues[i+4] === uniqueValues[i] + 4) {
                    isStraight = true;
                    highStraightValue = uniqueValues[i+4];
                    break;
                }
            }
        }
        if (isStraight) rank = Math.max(rank, 4);

        let isFlush = Object.values(suitsCount).some(count => count >= 5);
        if (isFlush) rank = Math.max(rank, 5);

        if (isStraight && isFlush) {
             rank = 8;
             if (highStraightValue === 14) rank = 9; 
        }
        
        return { rank: rank, name: HAND_RANKINGS[rank] };
    }

    // ----------------------------------------------------
    //  ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼é–¢æ•°
    // ----------------------------------------------------

    function resetGame(shouldShowRuleModal = true) {
        let currentChips = chips;

        // çŠ¶æ…‹ã‚’åˆæœŸåŒ–
        deck = [];
        dealerHand = [];
        playerHand = [];
        communityCards = [];
        pot = 0;
        dealerBet = 0;
        playerBet = 0;
        currentBettingRound = 0;
        isGameOver = true;
        isTutorial = false;
        tutorialStep = 0;
        
        // ãƒãƒƒãƒ—ã®ç¶­æŒ/ãƒªã‚»ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯
        if (shouldShowRuleModal) { 
            chips = INITIAL_CHIPS; // åˆå›/ãƒ«ãƒ¼ãƒ«ç¢ºèªæ™‚
        } else if (currentChips <= 0) {
             alert("ãƒãƒƒãƒ—ãŒå°½ãã¾ã—ãŸã€‚ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚åˆæœŸãƒãƒƒãƒ—ã§å†é–‹ã—ã¾ã™ã€‚");
             chips = INITIAL_CHIPS; 
        } else {
            chips = currentChips; // ãƒ—ãƒ¬ã‚¤å¾Œã®ãƒãƒƒãƒ—ã‚’ç¶­æŒ (æ¬¡ã®å‹è² ã¸)
        }

        // UIã®æ›´æ–°
        renderHands(false);
        updateDisplay();
        els.dealerHandStatus.textContent = '?';
        els.playerHandStatus.textContent = '?';
        
        // ãƒœã‚¿ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆ
        els.dealButton.style.display = 'block';
        els.tutorialButton.style.display = 'inline-block'; 
        els.actionButtons.style.display = 'none';
        els.postGameButtons.style.display = 'none';
        els.nextGameButton.textContent = 'æ¬¡ã®å‹è² ã¸'; 

        if (shouldShowRuleModal) {
            els.ruleModal.style.display = 'flex'; 
        } else {
            displayDealerMessage('start');
        }
    }

    function startGame() {
        if (isTutorial) return;
        const ante = parseInt(els.anteAmount.value);
        if (chips < ante) {
            displayDealerMessage('default', 0, '', 'ãƒãƒƒãƒ—ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ã‚¢ãƒ³ãƒ†ã‚£ã‚’æ¸›ã‚‰ã™ã‹ã€æ¬¡ã®ã‚²ãƒ¼ãƒ ã¸é€²ã‚“ã§ãã ã•ã„ã€‚');
            return;
        }

        isGameOver = false;
        createAndShuffleDeck();
        
        // ã‚¢ãƒ³ãƒ†ã‚£ã¨æ‰‹æœ­ã®å‡¦ç†
        chips -= ante;
        pot += ante * 2; 
        playerBet = ante;
        dealerBet = ante; 
        
        playerHand = [drawCard(), drawCard()];
        dealerHand = [drawCard(), drawCard()];

        renderHands(false);
        updateDisplay();

        displayDealerMessage('ante', ante);

        currentBettingRound = 0;
        
        // æœ€åˆã®ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹ (ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰ã‚¢ã‚¯ã‚·ãƒ§ãƒ³)
        dealerAction();
    }
    
    function isBettingRoundOver() {
        return dealerBet === playerBet && (dealerBet > 0 || currentBettingRound > 0 || (dealerBet === 0 && playerBet === 0));
    }

    function dealerAction() {
        if (isGameOver || isBettingRoundOver()) {
             els.actionButtons.style.display = 'none';
             if (isBettingRoundOver()) setTimeout(nextPhase, 1000); 
             return;
        }

        if (isTutorial) {
            handleTutorialDealerAction();
            return;
        }

        // é€šå¸¸ã‚²ãƒ¼ãƒ ã®ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼AIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæœ€çµ‚èª¿æ•´ï¼‰
        const cardsToEvaluate = [...dealerHand, ...communityCards];
        const dealerResult = evaluateHand(cardsToEvaluate);
        const requiredCall = playerBet - dealerBet;
        const currentPot = pot + dealerBet + playerBet;
        let action = 'check';
        let raiseAmount = 0;
        
        // å½¹ã®ãƒ©ãƒ³ã‚¯ã«åŸºã¥ã„ã¦ã€0 (ãƒã‚¤ã‚«ãƒ¼ãƒ‰) ã‹ã‚‰ 9 (ãƒ­ã‚¤ãƒ¤ãƒ«SF) ã®é–“ã§å‹ç‡ã‚’æ¦‚ç®—
        const winProbability = dealerResult.rank / 10;
        
        if (requiredCall > 0) {
            // **ã€æœ€çµ‚èª¿æ•´: ã‚³ãƒ¼ãƒ«/ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®ç²˜ã‚Šå¼·ã•å‘ä¸Šã€‘**
            
            // å¿…è¦ãªã‚³ãƒ¼ãƒ«é¡ãŒå…¨ãƒãƒƒãƒ—ã‚’è¶…ãˆã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
            if (requiredCall > chips) { action = 'fold'; } // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã¯é¿ã‘ã‚‹
            
            // ãƒãƒƒãƒˆã«å¯¾ã™ã‚‹å¿…è¦ãªã‚³ãƒ¼ãƒ«é¡ã®æ¯”ç‡ (Pot Odds) ã‚’è¨ˆç®—
            const potOdds = requiredCall / (currentPot + requiredCall);
            
            // å½¹ã®ãƒ©ãƒ³ã‚¯ã«åŸºã¥ã„ãŸå‹è² å¼·ã•ã®é–¾å€¤
            let callThreshold = 0.2 + (currentBettingRound * 0.1); 

            if (winProbability >= callThreshold) {
                // å‹ç‡ãŒé–¾å€¤ä»¥ä¸Šãªã‚‰ã‚³ãƒ¼ãƒ« (ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³)
                action = 'call';
            } else if (winProbability + 0.2 >= potOdds && Math.random() < 0.7) { 
                 // å‹ç‡ãŒPot Oddsã«æ¯”è¼ƒçš„è¿‘ã‘ã‚Œã°ã€70%ã®ç¢ºç‡ã§ã‚³ãƒ¼ãƒ«ï¼ˆ**ç²˜ã‚Šå¼·ã•**ã®èª¿æ•´ï¼‰
                 action = 'call';
            } else if (requiredCall < 30 && Math.random() < 0.3) {
                 // å°é¡ã®ãƒ™ãƒƒãƒˆãªã‚‰30%ã®ç¢ºç‡ã§ã‚³ãƒ¼ãƒ«ï¼ˆãƒ–ãƒ©ãƒ•å¯¾å¿œã®è¨±å®¹ç¯„å›²æ‹¡å¤§ï¼‰
                 action = 'call';
            } else {
                 action = 'fold'; // ã©ã†ã—ã¦ã‚‚ã‚ªãƒƒã‚ºã¨å½¹ãŒæ‚ªã„å ´åˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰
            }
        } 
        else {
            // ãƒã‚§ãƒƒã‚¯/ãƒ™ãƒƒãƒˆå¯èƒ½ãªå ´åˆ (æ”»æ’ƒæ€§ã®èª¿æ•´)
            if (winProbability > 0.6 || (dealerResult.rank >= 3 && Math.random() < 0.6)) { 
                // ã€èª¿æ•´ã€‘ã‚¹ãƒªãƒ¼ã‚«ãƒ¼ãƒ‰ä»¥ä¸Šã‚ã‚Œã°ã€60%ã®ç¢ºç‡ã§ç©æ¥µçš„ã«ãƒ™ãƒƒãƒˆ/ãƒ¬ã‚¤ã‚º
                action = 'bet';
                // ãƒãƒƒãƒˆã®1/2ï½2/3ã‚’ãƒ¬ã‚¤ã‚ºé¡ã®åŸºæº–ã«
                raiseAmount = Math.max(Math.floor(currentPot * (0.5 + Math.random() * 0.15)), playerBet + 10, 20); 
            } else {
                action = 'check';
            }
        }

        executeDealerAction(action, requiredCall, raiseAmount);
    }
    
    function executeDealerAction(action, requiredCall, raiseAmount) {
        if (action === 'fold') {
            endGame('dealer_fold');
        } else if (action === 'call') {
            pot += requiredCall;
            dealerBet += requiredCall;
            displayDealerMessage('dealer_call');
            
            if (isBettingRoundOver()) setTimeout(nextPhase, 1000);
            else playerActionPhase();
            
        } else if (action === 'bet') {
            const betAmount = raiseAmount;
            const toBet = betAmount - dealerBet;
            
            pot += toBet; 
            dealerBet = betAmount;
            displayDealerMessage('dealer_bet', betAmount);
            playerActionPhase();
            
        } else if (action === 'check') {
            displayDealerMessage('dealer_check');
            if (isBettingRoundOver()) setTimeout(nextPhase, 1000);
            else playerActionPhase();
        }
        updateDisplay();
    }

    // ... (ä»¥ä¸‹ã€ä»–ã®é–¢æ•°ã¨åˆæœŸåŒ–å‡¦ç†ã¯å¤‰æ›´ãªã—) ... 
    
    function playerActionPhase() {
        els.messagePopup.style.display = 'none'; 
        els.dealButton.style.display = 'none';
        els.postGameButtons.style.display = 'none';
        els.actionButtons.style.display = 'flex';
        
        const requiredCall = dealerBet - playerBet;
        
        els.foldButton.disabled = false;
        
        if (requiredCall > 0) {
            els.checkCallButton.textContent = `ã‚³ãƒ¼ãƒ« (${requiredCall})`;
            els.checkCallButton.disabled = chips < requiredCall;
            els.raiseButton.disabled = chips < requiredCall + 10;
        } else {
            els.checkCallButton.textContent = 'ãƒã‚§ãƒƒã‚¯';
            els.checkCallButton.disabled = false;
            els.raiseButton.disabled = chips < 10; 
        }
        
        els.raiseAmount.min = Math.max(requiredCall + 10, 10);
        if (parseInt(els.raiseAmount.value) < els.raiseAmount.min) {
            els.raiseAmount.value = els.raiseAmount.min;
        }
    }

    function handlePlayerAction(type) {
        if (isGameOver) return;
        
        const requiredCall = dealerBet - playerBet;
        const raiseAmount = parseInt(els.raiseAmount.value);
        
        if (type === 'fold') {
            endGame('player_fold');
            return;
        } 
        
        if (type === 'call_check') {
            if (requiredCall > 0) { // ã‚³ãƒ¼ãƒ«
                if (chips < requiredCall) return;
                chips -= requiredCall;
                pot += requiredCall;
                playerBet += requiredCall;
                displayDealerMessage('default', 0, '', `ã‚ãªãŸã¯ã‚³ãƒ¼ãƒ« (${requiredCall}) ã—ã¾ã—ãŸã€‚`);
            } else { // ãƒã‚§ãƒƒã‚¯
                displayDealerMessage('default', 0, '', 'ã‚ãªãŸã¯ãƒã‚§ãƒƒã‚¯ã—ã¾ã—ãŸã€‚');
            }
        }
        
        if (type === 'raise') {
            const totalBet = raiseAmount; 
            const toBet = totalBet - playerBet; 
            
            if (totalBet < requiredCall + 10 || chips < toBet) return;
            
            chips -= toBet;
            pot += toBet;
            playerBet = totalBet; 
            displayDealerMessage('default', 0, '', `ã‚ãªãŸã¯ ${totalBet} ã«ãƒ¬ã‚¤ã‚ºã—ã¾ã—ãŸã€‚`);
        }

        updateDisplay();
        
        // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ä¸­ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸ç§»è¡Œ
        if (isTutorial) {
            setTimeout(hideMessagePopup, 1000);
            return;
        }

        // é€šå¸¸ã‚²ãƒ¼ãƒ : ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¸ç§»è¡Œ
        if (isBettingRoundOver()) {
            setTimeout(nextPhase, 1000);
        } else {
            dealerAction();
        }
    }
    
    function nextPhase() {
        if (isGameOver) return;
        
        // ãƒãƒƒãƒˆã«ãƒ™ãƒƒãƒˆé¡ã‚’ç§»å‹•ã—ã€ãƒªã‚»ãƒƒãƒˆ
        pot += dealerBet + playerBet; 
        dealerBet = 0;
        playerBet = 0;

        currentBettingRound++;
        
        if (currentBettingRound === 1) { // Flop
            if (!isTutorial) communityCards.push(drawCard(), drawCard(), drawCard());
            displayDealerMessage('flop');
        } else if (currentBettingRound === 2) { // Turn
            if (!isTutorial) communityCards.push(drawCard());
            displayDealerMessage('turn');
        } else if (currentBettingRound === 3) { // River
            if (!isTutorial) communityCards.push(drawCard());
            displayDealerMessage('river');
        } else if (currentBettingRound >= 4) {
            showdown();
            return;
        }
        
        renderHands(false); 
        updateDisplay();

        if (isTutorial) {
            handleTutorialStep(); 
            return;
        }

        // æ¬¡ã®ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹ (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã‚¢ã‚¯ã‚·ãƒ§ãƒ³)
        playerActionPhase(); 
    }

    function showdown() {
        isGameOver = true;
        renderHands(true); 

        const playerResult = evaluateHand([...playerHand, ...communityCards]);
        const dealerResult = evaluateHand([...dealerHand, ...communityCards]);
        
        let winner;
        if (playerResult.rank > dealerResult.rank) winner = 'player';
        else if (playerResult.rank < dealerResult.rank) winner = 'dealer';
        else winner = 'push'; 
        
        let finalPot = pot + dealerBet + playerBet;

        if (winner === 'player') {
            chips += finalPot;
            displayDealerMessage('player_win_showdown', finalPot, playerResult.name);
        } else if (winner === 'dealer') {
            displayDealerMessage('dealer_win_showdown', 0, dealerResult.name);
        } else {
            chips += Math.floor(finalPot / 2);
            displayDealerMessage('push', finalPot);
        }

        pot = 0; dealerBet = 0; playerBet = 0;

        updateDisplay();
        els.dealButton.style.display = 'none';
        els.actionButtons.style.display = 'none';
        
        if (!isTutorial) {
             els.postGameButtons.style.display = 'block';
        } else {
             handleTutorialStep(); // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®æœ€çµ‚ã‚¹ãƒ†ãƒƒãƒ—ã¸
        }
    }

    function endGame(reason) {
        isGameOver = true;
        let finalPot = pot + dealerBet + playerBet;
        
        if (reason === 'player_fold') {
            displayDealerMessage('player_fold', finalPot);
        } else if (reason === 'dealer_fold') {
            chips += finalPot;
            displayDealerMessage('dealer_fold', finalPot);
        }
        
        pot = 0; dealerBet = 0; playerBet = 0;

        updateDisplay();
        els.dealButton.style.display = 'none';
        els.actionButtons.style.display = 'none';
        els.postGameButtons.style.display = 'block';
    }


    // ----------------------------------------------------
    //  ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«æ©Ÿèƒ½ (ç°¡ç´ åŒ–)
    // ----------------------------------------------------

    function startTutorial() {
        resetGame(false); 
        isTutorial = true;
        tutorialStep = 0;
        
        chips = 200; 
        els.anteAmount.value = 10;
        
        // å›ºå®šã®ã‚«ãƒ¼ãƒ‰ã‚’è¨­å®š 
        playerHand = [makeCard('â™¥', 'Q'), makeCard('â™¥', 'K')]; 
        dealerHand = [makeCard('â™ ', '7'), makeCard('â™£', '7')]; 
        communityCards = [];
        
        updateDisplay();
        renderHands(false);
        els.dealButton.style.display = 'none';
        
        displayDealerMessage('default', 0, '', 'ã‚ˆã†ã“ããƒãƒ¼ã‚«ãƒ¼ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã¸ï¼<br>åŸºæœ¬çš„ãªæµã‚Œã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å­¦ã³ã¾ã™ã€‚');
    }

    function handleTutorialDealerAction() {
        if (tutorialStep === 5) {
            // ãƒã‚§ãƒƒã‚¯ã‚’å¼·åˆ¶
            displayDealerMessage('dealer_check');
            playerActionPhase(); 
        } else if (tutorialStep === 7) {
            // ã‚³ãƒ¼ãƒ«ã‚’å¼·åˆ¶
            const requiredCall = playerBet - dealerBet;
            pot += requiredCall;
            dealerBet += requiredCall;
            displayDealerMessage('dealer_call');
            // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«é€²è¡Œ
            setTimeout(hideMessagePopup, 1000);
        }
        updateDisplay();
    }

    function handleTutorialStep() {
        tutorialStep++;
        
        switch(tutorialStep) {
            case 1:
                displayDealerMessage('default', 0, '', 'ã‚¢ãƒ³ãƒ†ã‚£10ãƒãƒƒãƒ—ã‚’è³­ã‘ã¾ã—ãŸã€‚<span class="highlight">æ‰‹æœ­2æš</span>ãŒé…ã‚‰ã‚Œã¾ã™ã€‚');
                chips -= 10; pot += 20; playerBet = 10; dealerBet = 10; updateDisplay();
                break;
            case 2:
                displayDealerMessage('default', 0, '', 'ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãŒ20ãƒãƒƒãƒ—ã« <span class="highlight">ãƒ¬ã‚¤ã‚º</span> ã—ã¦ãã¾ã—ãŸã€‚ã‚³ãƒ¼ãƒ« (10) ã‚’é¸ã³ã€å‹è² ã«ä¹—ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚');
                pot += 10; dealerBet += 10; updateDisplay(); playerActionPhase();
                break; 
            case 3: // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚³ãƒ¼ãƒ«å®Œäº†
                displayDealerMessage('default', 0, '', 'ã‚³ãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸã€‚<span class="highlight">ãƒ•ãƒ­ãƒƒãƒ—</span> (3æš) ãŒå…¬é–‹ã•ã‚Œã¾ã™ã€‚');
                break;
            case 4: // ãƒ•ãƒ­ãƒƒãƒ—å¾Œã®èª¬æ˜
                communityCards = [makeCard('â™£', 'T'), makeCard('â™ ', 'J'), makeCard('â™¦', 'A')]; 
                renderHands(false);
                pot += dealerBet + playerBet; dealerBet = 0; playerBet = 0; updateDisplay();
                playerActionPhase();
                displayDealerMessage('default', 0, '', 'ãƒ•ãƒ­ãƒƒãƒ—ãŒé–‹ãã¾ã—ãŸã€‚èª°ã‚‚ãƒ™ãƒƒãƒˆã—ã¦ã„ãªã„ã®ã§ã€ä»Šå›ã¯ <span class="highlight">ãƒã‚§ãƒƒã‚¯</span> ã§ã‚¿ãƒ€ã§æ¬¡ã®ã‚«ãƒ¼ãƒ‰ã‚’è¦‹ã¾ã—ã‚‡ã†ã€‚');
                break; 
            case 5: // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒã‚§ãƒƒã‚¯å®Œäº† (ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã‚‚ãƒã‚§ãƒƒã‚¯)
                displayDealerMessage('default', 0, '', 'ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã‚‚ãƒã‚§ãƒƒã‚¯ã€‚4æšç›®ã®ã‚«ãƒ¼ãƒ‰ã€<span class="highlight">ã‚¿ãƒ¼ãƒ³</span> ãŒé–‹ã‹ã‚Œã¾ã™ã€‚');
                break;
            case 6: // ã‚¿ãƒ¼ãƒ³å¾Œã®èª¬æ˜ (ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆå®Œæˆ)
                communityCards.push(makeCard('â™¥', 'Q'));
                renderHands(false);
                pot += dealerBet + playerBet; dealerBet = 0; playerBet = 0; updateDisplay();
                playerActionPhase();
                els.raiseAmount.value = 30;
                displayDealerMessage('default', 0, '', 'ã‚¿ãƒ¼ãƒ³ãŒé–‹ãã¾ã—ãŸï¼<span class="highlight">ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆãŒå®Œæˆ</span>ã§ã™ï¼ãƒ¬ã‚¤ã‚º (30) ã‚’é¸ã³ã€ãƒãƒƒãƒ—ã‚’å¢—ã‚„ã—ã¾ã—ã‚‡ã†ï¼');
                break; 
            case 7: // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ¬ã‚¤ã‚ºå®Œäº† (ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã‚‚ã‚³ãƒ¼ãƒ«)
                displayDealerMessage('default', 0, '', 'ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãŒã‚³ãƒ¼ãƒ«ã€‚æœ€å¾Œã®ã‚«ãƒ¼ãƒ‰ã€<span class="highlight">ãƒªãƒãƒ¼</span> ãŒé–‹ã‹ã‚Œã¾ã™ã€‚');
                break;
            case 8: // ãƒªãƒãƒ¼å¾Œã®ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã¸
                communityCards.push(makeCard('â™¦', '2'));
                renderHands(false);
                nextPhase(); // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã¸
                tutorialStep = 9;
                break;
            case 9:
                displayDealerMessage('default', 0, '', 'ãŠã‚ã§ã¨ã†ï¼ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã§å‹åˆ©ã—ã¾ã—ãŸã€‚');
                els.postGameButtons.style.display = 'block';
                els.nextGameButton.textContent = 'é€šå¸¸ã‚²ãƒ¼ãƒ ã¸'; 
                // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«çµ‚äº†å¾Œã®å‡¦ç†ã‚’ã“ã“ã§å®Ÿè¡Œ
                els.nextGameButton.removeEventListener('click', els.nextGameButton.resetHandler);
                els.nextGameButton.addEventListener('click', () => {
                    alert('ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’çµ‚äº†ã—ã€é€šå¸¸ã‚²ãƒ¼ãƒ ã¸ç§»è¡Œã—ã¾ã™ã€‚');
                    chips = INITIAL_CHIPS; 
                    resetGame(false); 
                }, { once: true }); // 1å›å®Ÿè¡Œã—ãŸã‚‰ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                break;
        }
    }


    // ----------------------------------------------------
    //  ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ / åˆæœŸåŒ–
    // ----------------------------------------------------

    // DOMã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå¾Œã«å®Ÿè¡Œ
    document.addEventListener('DOMContentLoaded', () => {
        // é€šå¸¸ã®ã€Œæ¬¡ã®å‹è² ã¸ã€ã®å‹•ä½œã‚’å®šç¾©
        const normalNextGameHandler = () => resetGame(false);
        els.nextGameButton.resetHandler = normalNextGameHandler; // å‚ç…§ç”¨

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        els.dealButton.addEventListener('click', startGame);
        els.nextGameButton.addEventListener('click', normalNextGameHandler); // é€šå¸¸å‹•ä½œã‚’è¨­å®š
        els.foldButton.addEventListener('click', () => handlePlayerAction('fold'));
        els.checkCallButton.addEventListener('click', () => handlePlayerAction('call_check'));
        els.raiseButton.addEventListener('click', () => handlePlayerAction('raise'));
        els.tutorialButton.addEventListener('click', startTutorial);
        els.ruleButton.addEventListener('click', () => { els.ruleModal.style.display = 'flex'; });
        els.closeModal.addEventListener('click', () => { els.ruleModal.style.display = 'none'; });

        // åˆå›è¡¨ç¤º: ãƒ«ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        updateDisplay();
        els.ruleModal.style.display = 'flex';
    });
</script>
</body>
</html>
